《计算机程序的构造和解释》的笔记以及习题，笔记只记录一些必要的部分。

```
(+ 1 2)
(+ (* 1 3 2) 1)
(define x 1)
(define (sqrt x)  (* x x))
```



应用序：先求值而后应用

正则序：完全展开而后规约



```
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))

(define (abs x)
  (cond ((< x 0) -x)
        (else x)))
        
  (define (abs x)
  (if (< x 0)
      (- x)
      x))
```





```
练习1.1
10
12
8
3
(+ 8 -2) 6


(+ 3 4 (* 3 4))  19
#f
4
16
6
-4

练习1.2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

练习1.3
(define (max-of-three a b c)
  (if (> a b)
      (if (> a c)
          a
          c)
      (if (> b c)
          b
          c)))

练习1.4         
计算a+abs(b).返回值可以为运算符

练习1.5
应用序：死循环；正则序：返回0；sheme为应用序
```



牛顿法求平方根

| 猜测   | 商     | 平均值 |
| ------ | ------ | ------ |
| 1      | 2/1=2  | 1.5    |
| 1.5    | 1.3333 | 1.4167 |
| 1.4167 | 1.4118 | 1.4142 |
| 1.4142 |        |        |

```
;若guess足够好，则返回guess，否则提升guess精度继续迭代
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (square x)
  (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))
```



```
练习1.6
运行new-if会发生死循环
if会在predicate为真，才会计算then-clause、else-clause
而new-if会同时计算三者

练习1.7
(define (good-enough? preguess guess)
  (< (/ (abs (- preguess guess)) preguess) 0.001))
  
(define (sqrt-iter preguess guess x)
  (if (good-enough? preguess guess)
      guess
      (sqrt-iter guess (improve guess x) x)))

练习1.8
(define (curt-iter preguess guess x)
  (if (good-enough? preguess guess)
      guess
      (curt-iter guess (improve guess x) x)))
(define (good-enough? preguess guess)
  (< (/ (abs (- preguess guess)) preguess) 0.001))
(define (improve guess x)
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))
(define (curt x)
  (curt-iter x 1.0 x))
```

一个过程的定义**约束**了它的所有形式参数

```
;块结构
(define (sqrt x)
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (sqrt-iter 1.0 x))
  
;词法作用域
;x作为内部定义自由遍历
(define (sqrt x)
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (sqrt-iter 1.0))
```

递归计算，线性递归过程

```
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
```

![](https://gitee.com/csjuesz/image/raw/master/20210416222444.png)

迭代计算过程，线性迭代过程。状态可以用固定数目描述

```
(define (facorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
```

![image-20210416222613765](https://gitee.com/csjuesz/image/raw/master/20210416222613.png)

```
练习1.9
(inc (+ (dec 4) 5))=(inc (+ 3 5))=(inc (inc (+ 2 5)))=(inc (inc (inc (+ 1 5))))=(inc (inc (inc (inc (+ 0 5)))))=(inc (inc (inc (inc 5))))
(+ 3 6)=(+ 2 7)=(+ 1 8)=(+ 0 9)=9
1递归 2迭代

练习1.10
(A 0 y)=2*y
(A 1 y)=(A 0 (A 0 (A 0 ...(A 1 1))))=2^n
(A 2 y)=(A 1 (A 1 (A 1 ...(A 2 1))))=2^2^2...2

(A x+1 y) = (A x)^y 2

A(1 10)=2^10
A(2 4)=2^2^2^2
A(3 3)=2^2^2^2		
```

树形递归

```
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

![](https://gitee.com/csjuesz/image/raw/master/20210416231631.png)

迭代法

```
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
```

